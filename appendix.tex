

\section{Effects of the simulation's finiteness}
\label{app:finite}

Theoretical results about the queuing construction apply in principle to an infinite stream. However, simulations are necessarily finite, and for very large windows (that are approximately the same size as the whole stream) this causes interesting artefacts in the error rates.

Note that these effects have very little impact on practical implementations of queuing filters, since almost all use cases assume a window size much smaller than the stream (or, equivalently, a very large stream). Nevertheless we illustrate the effect of the finite simulation and the parameters affecting it, if only to motivate a further analytical study of this phenomenon.

Figure~\ref{fig:strangess} measures the error rate as a function of $w$, for different stream sizes $N$. A visible decrease in $ER$ can be found around $w\approx N$. While we do not have any explanation for the difference in the peaks sizes and exact location, we give the hypothesis that it is related to the choice of $|\Gamma|$.

\begin{figure}[t]
%\makebox[\textwidth]{\makebox[1.05\textwidth]{%
%	\begin{minipage}{.5\textwidth}
	\centering
		\input{graphs/stream_size_qht.tex}
		\caption{Error rate for queuing QHT ($L = 10$, $M = 10^5$, $|\Gamma| = 2^{16}$) with streams of size $10^5$ to $10^8$.}\label{fig:strangess}
%	\end{minipage}
%\hfill
\end{figure}



As can be seen on this simulation, there is only disagreement around $w \approx N/L$, and increasing $N$ results in a later and smaller peak. 

It is also possible to run simulations for different alphabet sizes $\Gamma$, which shows that the peak's position increases with $|\Gamma|$, although the relationship is not obvious to quantify.

\section{Filters vs queued filters (complement)}\label{app:improvement}
We here run a comparison of the Cuckoo Filter relative to the Queueing Cuckoo Filter, as well as the SBF relatively to the queueing SBF. The results are given in Figure~\ref{fig:appendix_improvement}.

\begin{figure}[t]
	\centering
	\begin{tikzpicture}
		\begin{semilogxaxis}[
			legend cell align = left,%
			legend pos=south east,
			legend style={nodes={scale=0.7, transform shape}},
			%			legend style={at={(0.02,0.98)},anchor=north west},%
			xlabel=$w$, ylabel=$\FPR^w + \FNR^w (\times 100)$]
		\addplot[color=teal, mark=triangle] table[x=w,y=Error] {graphs/Queueing_Cuckoo.dat};
		\addlegendentry{Q\_Cuckoo};
		\addplot[color=teal, mark=triangle, dashed] table[x=w,y=Error] {graphs/Cuckoo.dat};
		\addlegendentry{Cuckoo};
		%%
		\addplot[color=olive, mark=square, mark options = {scale=0.7}] table[x=w,y=Error] {graphs/Queueing_StableBloom.dat};
		\addlegendentry{Q\_SBF};
		\addplot[color=olive, mark=square, mark options = {scale=0.7}, dashed] table[x=w,y=Error] {graphs/SBF.dat};
		\addlegendentry{SBF};
		\end{semilogxaxis}
	
	\end{tikzpicture}
	\caption{Comparing performances of the Cuckoo and SBF filters, in `vanilla' setting or when placed in our queueing structure.}\label{fig:appendix_improvement}

\end{figure}
%\section{Compact Hash Short Filter}\label{app:CSHF}
%Removing the dictionary from the SHF construction yields a more memory-efficient, but less time-efficient construction, which we dub \enquote{compact} short hash filter (CSHF). The CSHF performs in linear time in $w$, and is a simple double-ended queue, the only point is that instead of storing $e$, the filter stores $h(e)$, where $h$ is a hash function of codomain size $\lfloor \frac Mw \rfloor$.% and is described in Algorithm~\ref{alg:CSHF}.
%
%%\begin{algorithm}[!h]
%%	\caption{CSHF, Setup, Lookup and Insert}\label{alg:CSHF}
%%	
%%	\begin{algorithmic}[1]
%%		\Function{Setup}{$\mathcal M, w$}
%%		\Comment $M$ is the available memory, $w$ the size of the sliding window
%%		\State $h \gets$ hash function of codomain size $\lfloor \frac Mw \rfloor$
%%		\State $Q \gets \emptyset$ \Comment $Q$ is a queue of elements of size $h$
%%		\State\Return filter
%%		\EndFunction 
%%		\item[]
%%	\end{algorithmic}
%%	
%%	\begin{algorithmic}[1]
%%		\Function{Lookup}{$e$}
%%		\State \Return $h(e) \in Q$ 
%%		\EndFunction
%%		\item[]
%%	\end{algorithmic}
%%	
%%	\begin{algorithmic}[1]
%%		\Function{Insert}{$e$}
%%		\State $Q.\mathsf{Push\_Front}(h(e))$
%%		
%%		\If{$Q.\mathsf{length}() > w$}
%%			\State $h' \gets Q.\mathsf{Pop\_back}()$
%%		\EndIf
%%		\EndFunction
%%	\end{algorithmic}
%%\end{algorithm}
%
%\paragraph{Error Rate.}
%Let $w> 0$ be a window size and $M > 0$ the available memory.
%
%%We write $\FN^w_\text{SHF}$ the probability of false negative of an SHF with these parameters. We similarly define $\FP^w_\text{SHF}$.%, $\FN^w_\text{CSHF}$, $\FP^w_\text{CSHF}$. 
%
%\begin{restatable}{thm}{fprCHF}\label{thm:fprCHF}	
%	$\FN_\text{CSHF}^w  = 0$  and $\FP_\text{CSHF}^w = 1 - \left(1 - 2^{-M/w}\right)^w$
%\end{restatable}
%
%\begin{proof}
%	This is an immediate adaptation of the proof from Theorem~\ref{thm:SHF}. A CSHF has fingerprints of size $h' = \frac Mw$.
%\end{proof}
%
%\paragraph{Remark:} A CSHF of size $M$ on a sliding window $w$ has the same error rate than an SHF of sliding window of size $2M + w\log_2 w$.
%
%\paragraph{Saturation.}
%Simlarly to SHF, CSHF saturates quickly over a certain $w_\text{max}$. We compare SHF and CSHF saturations in Figure~\ref{fig:app_shorts}.
%
%
%\begin{figure}[t]
%		\centering
%		\input{graphs/bench_shorts_both.tex}
%		\caption{Error rates of SHFs and CSHFs for $M = 10^5$ bits, for varying window sizes $w$.}\label{fig:app_shorts}
%\end{figure}
%
%Experimentally, we get $w_\text{max}^\text{CSHF} = 0.0627 M + 443$ ($r^2 = 0.9981$).
